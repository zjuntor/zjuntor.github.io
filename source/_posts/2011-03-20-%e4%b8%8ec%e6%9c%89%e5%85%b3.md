---
title: 与C有关
author: torrge
comments: true
layout: post
permalink: /2011/03/%e4%b8%8ec%e6%9c%89%e5%85%b3/
categories:
  - Programming
tags:
  - C
  - Fibonacci
  - Recursion
---
如题，现在开始说说与C有关的事。

用一个有意思的例子开始话题，考虑有如下代码段：

<pre class="brush:cpp">int array[]={1,2,3};
</pre>

array[2]，就是整形一维数组array的第三个元素。那么 2[array] 呢？ 好，你没看错，我也没码错。而这个2[array] 确实也是整形一维数组array的第三个元素，跟array[2] 是等价的。

这个诡异的技巧，源于C实现下标的方法。换个角度理解，[] 操作符作用于array，2两个操作数，等价于 \*(array+2)，那么\*(2+array) 也是等价的。

**递归Fibonacci 的C 实现**

<pre class="brush:cpp">long
fibonacci(int n){
    if(n&lt;2)
        return 1;
    return fibonacci(n-1) + fibonacci(n-2);
}</pre>

想必朋友们学递归的时候跟我一样，用的是那本绿皮书，也是用Fibonacci 数列的生成来作为例子的，以至于看到Fibonacci 条件反射地想起上面的递归实现。那这么做开销有多大呢？下面来看看。

粗略地估计一下，在递归计算fibonacci(10) 的时候 fibonacci(3) 的值被重复计算了21 次，n 值更大的时候，开销是惊人的。

严格的算法分析结果证实，采用上述的递归实现来计算Fibonacci 数列的开销为 O(1.5^N)，确实很可怕。

事实上，尾部递归(tail recursion) 可以很方便地转换城简单的循环，所谓尾部递归(tail recursion)，即递归调用是函数的最后一项任务的递归。