---
title: 与C有关(二)
author: torrge
comments: true
layout: post
permalink: /2011/03/%e4%b8%8ec%e6%9c%89%e5%85%b3%e4%ba%8c/
categories:
  - Programming
tags:
  - Bit Array
  - Bit Vector
  - C
  - Sort
---
接着说与C 有关的事，正整数位向量排序的C 实现。

**位向量(Bit Array)**

位向量(Bit Array)，说的是这么一个东西，它可以用N 个Bit 来表示一个所有元素都小于 N的简单的非负整数的集合。譬如，“01110100100001000000” 可以用来表示集合 {1,2,3,5,8,13}。

**正整数位向量排序**

正整数位向量排序说的是这么一回事，用一个位向量表示要排序的正整数集合，然后排序。具体做法是：

*   从文件中循环读入要排序的正整数，并把位向量的对应bit 置为1。譬如读入正整数10，就将位向量的第十个Bit 置为1(当然，前提是位向量中所有位都已初始化为0)；
*   从第一个Bit 开始到最后一个Bit 顺序遍历整个位向量，如果某个Bit 值为1，就将它输出到结果文件。譬如第22个Bit 值为1，就将22输出到文件；
*   最后，打开结果文件，结果，那就是了。

**正整数位向量排序的C 实现**

假定有一千万个小于一千万的正整数要排序，用一个unsign char 数组来存储各个Bit。

<pre class="brush:cpp">unsigned char vector_array[1250000];</pre>

接下来两个函数用于实现将vector\_array 中指定的Bit 设为1，和获取vector\_array 中指定的Bit 的值。

<pre class="brush:cpp">/*
**将vector_array 表示的位向量中第index 个Bit 置为1
*/
void set_value_at(unsigned char vector_array[],long index){
	long real_index = index / 8;
	long bit_index_at = index % 8;
	vector_array[real_index] = vector_array[real_index] | (1 &lt;&lt; bit_index_at);
}

/*
**获取vector_array 表示的位向量中第index 个Bit 的值
*/
unsigned char get_value_at(unsigned char const vector_array[],long index){
	long real_index = index / 8;
	long bit_index_at = index % 8;
	unsigned char bits = vector_array[real_index];
	return (bits &gt;&gt; bit_index_at) % 2;
}</pre>

排序过程

<pre class="brush:cpp">int
main(int argc, char **argv){
	FILE *fp = fopen("/path/to/data.bin","rb");
	long value;
	long index;
	unsigned char vector_array[10000000];

	for(index=0;index&lt;10000000;index++)
		vector_array[index] = 0;

	while(!feof(fp)){
		fread(&value,sizeof value,1,fp);
		set_value_at(vector_array,value);
	}

	fclose(fp);
	fp = fopen("/path/to/data_result.bin","wb");

	for(index=0;index&lt;10000000;index++)
		if(value = get_value_at(vector_array,index))
			fwrite(&index,sizeof index,1,fp);
	fclose(fp);

	return 0;
}</pre>

正整数位向量排序由于只有两个循环，一个用于将数据存入位向量，一个用于结果输出，如果算那个初始化位向量的循环，算法复杂度仍然还是O(N)，同时粗略的估计一下，如果每个正整数都用一个long 整形表示的话，大概需要近40M内存。而采用位向量，则需要1M+的内存，简直太梦幻了。然而，正整数位向量排序有如下的限定条件：

*   各个整数没有重复出现；
*   必须是正整数(这句是废话)。

总结一下，数据结构决定算法。

Ref: <a href="http://book.douban.com/subject/1484451/" target="_blank"><Programming Pearls></a>